#include "world_map.h"

#include <fstream>
#include "types/utility.h"

namespace gslam {
  using namespace srrg_core;

  TrackingContext::TrackingContext(): _previous(0),
                                      _current_to_previous_initial(TransformMatrix3D::Identity()),
                                      _previous_to_current_initial(_current_to_previous_initial.inverse())
#if CV_MAJOR_VERSION == 2
                                      ,_descriptor_extractor(new cv::BriefDescriptorExtractor(DESCRIPTOR_SIZE_BYTES)) {
#elif CV_MAJOR_VERSION == 3
                                      ,_descriptor_extractor(cv::xfeatures2d::BriefDescriptorExtractor::create(DESCRIPTOR_SIZE_BYTES)) {
#else
  #error OpenCV version not supported
#endif
    clear();
    std::cerr << "TrackingContext::TrackingContext|constructed" << std::endl;
  };

  TrackingContext::~TrackingContext() {

    std::cerr << "TrackingContext::TrackingContext|destroying" << std::endl;
    for(LandmarkPtrMap::iterator it=_landmarks.begin(); it!=_landmarks.end(); it++)
      delete it->second;

    for(FramePtrMap::iterator it=_frames.begin(); it!=_frames.end(); it++)
      delete it->second;
    std::cerr << "TrackingContext::TrackingContext|destroyed" << std::endl;
  }

  void TrackingContext::clear() {
    _root_frame       = 0;
    _current_frame    = 0;
    _previous_frame   = 0;
    _current_keyframe = 0;
    _frame_queue_for_keyframe.clear();
    _landmarks.clear();
    _frames.clear();
    _keyframes.clear();
    setRobotToWorldPrevious(TransformMatrix3D::Identity());
  }
  
  Frame* TrackingContext::createNewFrame(const TransformMatrix3D& frame_to_world_guess_, const Identifier& sequence_number_raw_){
    if (_previous_frame) {
      _previous_frame->releaseImages();
    }
    _previous_frame = _current_frame;
    _current_frame  = new Frame(this, _previous_frame, 0, frame_to_world_guess_, sequence_number_raw_);

    if (_root_frame == 0) {
      _root_frame = _current_frame;
    }

    if (_previous_frame) {
      _previous_frame->setNext(_current_frame);
    }

    _frames.put(_current_frame);
    _frame_queue_for_keyframe.push_back(_current_frame);
    return _current_frame;
  }

  void TrackingContext::createNewKeyframe() {
    _generated_keyframe = false;
    _closed_keyframe    = false;

    //ds update distance traveled and last pose
    const TransformMatrix3D robot_pose_last_to_current = _previous_frame->worldToRobot()*_current_frame->robotToWorld();
    _distance_traveled_window += robot_pose_last_to_current.translation().norm();
    _degrees_rotated_window   += Utility::toOrientationRodrigues(robot_pose_last_to_current.linear()).norm();

    //ds check if we can generate a keyframe - if generated by translation only a minimum number of frames in the buffer is required - or a new tracking context
    if (_degrees_rotated_window   > _minimum_degrees_rotated_for_keyframe                                                                                 ||
        (_distance_traveled_window > _minimum_distance_traveled_for_keyframe && _frame_queue_for_keyframe.size() > _minimum_number_of_frames_for_keyframe)||
        (_frame_queue_for_keyframe.size() > _minimum_number_of_frames_for_keyframe && _keyframes.size() < 5)                                              ) {

      //ds create the new keyframe and add it to the keyframe database
      _current_keyframe = new KeyFrame(_current_frame, _frame_queue_for_keyframe);
      _keyframes.push_back(_current_keyframe);
      _generated_keyframe = true;

      //ds reset generation properties
      resetWindow();

      //ds current frame is now a keyframe - update structures
      _current_frame = _current_keyframe;
      _frames.replace(_current_frame);

//      std::cerr << "TrackingContext::createNewKeyframe|created keyframe: " << _current_frame->index() << " in context: " << index() << std::endl;
    }
  }
  
  Landmark* TrackingContext::createNewLandmark(const PointCoordinates& coordinates_in_world_){
    Landmark* landmark = new Landmark(coordinates_in_world_);
    landmark->createNewItem(landmark->coordinates());
    _landmarks.put(landmark);
    return landmark;
  }

  void TrackingContext::closeKeyframes(KeyFrame* query_,
                                       const KeyFrame* reference_,
                                       const TransformMatrix3D& transform_query_to_reference_) {
    query_->add(reference_, transform_query_to_reference_);
    _closed_keyframe = true;
  }

  void TrackingContext::resetWindow() {
    _distance_traveled_window = 0.0;
    _degrees_rotated_window   = 0.0;
  }

  void TrackingContext::absorb(TrackingContext* context_query_, const TransformMatrix3D& transform_query_world_to_reference_world_) {

    //ds iterate over all landmarks (order does not matter)
    for(LandmarkPtrMapElement landmark_with_index: context_query_->landmarks()) {

      //ds merge landmark properties
      Landmark* landmark = landmark_with_index.second;
      const PointCoordinates& coordinates_in_reference = transform_query_world_to_reference_world_*landmark->coordinates();
      landmark->setCoordinates(coordinates_in_reference);
      landmark->resetCoordinates();

      //ds add to control structure
      _landmarks.put(landmark);
    }

    //ds iterate over all frames (order does matter)
    Frame* frame = context_query_->rootFrame();
    while (frame) {

      //ds merge frame properties
      frame->setTrackingContext(this);
      const TransformMatrix3D& frame_to_world_in_reference = transform_query_world_to_reference_world_*frame->robotToWorld();
      frame->setRobotToWorld(frame_to_world_in_reference);

      //ds add to control structure
      _previous_frame = _current_frame;
      _current_frame  = frame;
      _current_frame->setPrevious(_previous_frame);
      _previous_frame->setNext(_current_frame);
      _frames.put(_current_frame);

      //ds check if the frame is a keyframe
      if (_current_frame->isKeyFrame()) {
        KeyFrame* keyframe_in_reference = static_cast<KeyFrame*>(_current_frame);
        keyframe_in_reference->updateSubContext();
        _current_keyframe = keyframe_in_reference;
        _keyframes.push_back(keyframe_in_reference);
      }

      //ds move on
      frame = _current_frame->next();
    }

    //ds update last position
    setRobotToWorldPrevious(_current_frame->robotToWorld());

    //ds purge ties to all objects in the absorbed context
    context_query_->clear();
    delete context_query_;
  }

  void TrackingContext::purifyLandmarks() {

    //ds deactivate all landmarks which are not optimized
    for (const LandmarkPtrMapElement landmark_element: _landmarks) {
      if (!landmark_element.second->isOptimized()) {
        landmark_element.second->setIsContained(false);
      }
    }
  }

  //ds dump trajectory to file (in KITTI benchmark format only for now)
  void TrackingContext::writeTrajectory(const std::string& filename_) const {

    //ds construct filename
    std::string filename(filename_);

    //ds if not set
    if (filename_ == "") {

      //ds generate generic filename with timestamp
      filename = "trajectory-"+std::to_string(static_cast<uint64_t>(std::round(srrg_core::getTime())))+".txt";
    }

    //ds open file stream (overwriting)
    std::ofstream outfile_trajectory(filename, std::ifstream::out);
    assert(outfile_trajectory.good());

    //ds for each frame (assuming continuous, sequential indexing)
    for (Index index_frame = 0; index_frame < _frames.size(); ++index_frame) {

      //ds buffer transform
      const TransformMatrix3D& robot_to_world = _frames.at(index_frame)->robotToWorld();

      //ds dump transform according to KITTI format
      for (uint8_t u = 0; u < 3; ++u) {
        for (uint8_t v = 0; v < 4; ++v) {
          outfile_trajectory << robot_to_world(u,v) << " ";
        }
      }
      outfile_trajectory << "\n";
    }
    outfile_trajectory.close();
    std::cerr << "WorldContext::WorldContext|saved trajectory to: " << filename << std::endl;
  }
}

