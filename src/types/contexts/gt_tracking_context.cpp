#include "gt_tracking_context.h"

#include "types/gt_utility.h"

namespace gslam {
  using namespace srrg_core;

  Identifier TrackingContext::_instances = 0;

  TrackingContext::TrackingContext(): _previous(0),
                                      _current_to_previous_initial(TransformMatrix3D::Identity()),
                                      _previous_to_current_initial(_current_to_previous_initial.inverse()),
#if CV_MAJOR_VERSION == 2
                                      _descriptor_extractor(new cv::BriefDescriptorExtractor(DESCRIPTOR_SIZE_BYTES)),
#elif CV_MAJOR_VERSION == 3
                                      _descriptor_extractor(cv::xfeatures2d::BriefDescriptorExtractor::create(DESCRIPTOR_SIZE_BYTES)),
#else
  #error OpenCV version not supported
#endif
                                      _index(_instances) {
    clear();
    ++_instances;
    LOG_INFO("TrackingContext::TrackingContext", "constructed with index: " + std::to_string(_index));
  };

  TrackingContext::TrackingContext(TrackingContext* context_): _previous(context_),
                                                               _current_to_previous_initial(context_->robotToWorldPrevious()),
                                                               _previous_to_current_initial(_current_to_previous_initial.inverse()),
#if CV_MAJOR_VERSION == 2
                                                               _descriptor_extractor(new cv::BriefDescriptorExtractor(DESCRIPTOR_SIZE_BYTES)),
#elif CV_MAJOR_VERSION == 3
                                                               _descriptor_extractor(cv::xfeatures2d::BriefDescriptorExtractor::create(DESCRIPTOR_SIZE_BYTES)),
#else
  #error OpenCV version not supported
#endif
                                                               _index(_instances) {
    context_->setNext(this);
    clear();
    ++_instances;
    LOG_INFO("TrackingContext::TrackingContext", "constructed (copy) with index: " + std::to_string(_index));
  };

  TrackingContext::~TrackingContext() {

    LOG_INFO("TrackingContext::TrackingContext", "destroying with index: " + std::to_string(_index));

    for(LandmarkPtrMap::iterator it=_landmarks.begin(); it!=_landmarks.end(); it++)
      delete it->second;

    for(FramePtrMap::iterator it=_frames.begin(); it!=_frames.end(); it++)
      delete it->second;

    LOG_INFO("TrackingContext::TrackingContext", "destroyed with index: " + std::to_string(_index));
  }

  void TrackingContext::clear() {
    _root_frame       = 0;
    _current_frame    = 0;
    _previous_frame   = 0;
    _current_keyframe = 0;
    _frame_queue_for_keyframe.clear();
    _landmarks.clear();
    _frames.clear();
    _keyframes.clear();
    setRobotToWorldPrevious(TransformMatrix3D::Identity());
  }
  
  Frame* TrackingContext::createNewFrame(const TransformMatrix3D& frame_to_world_guess_, const Identifier& sequence_number_raw_){
    if (_previous_frame) {
      _previous_frame->releaseImages();
    }
    _previous_frame = _current_frame;
    _current_frame  = new Frame(this, _previous_frame, 0, frame_to_world_guess_, sequence_number_raw_);

    if (_root_frame == 0) {
      _root_frame = _current_frame;
    }

    if (_previous_frame) {
      _previous_frame->setNext(_current_frame);
    }

    _frames.put(_current_frame);
    _frame_queue_for_keyframe.push_back(_current_frame);
    return _current_frame;
  }

  void TrackingContext::createNewKeyframe() {
    _generated_keyframe = false;
    _closed_keyframe    = false;

    //ds update distance traveled and last pose
    const TransformMatrix3D robot_pose_last_to_current = _previous_frame->worldToRobot()*_current_frame->robotToWorld();
    _distance_traveled_window += robot_pose_last_to_current.translation().norm();
    _degrees_rotated_window   += Utility::toOrientationRodrigues(robot_pose_last_to_current.linear()).norm();

    //ds check if we can generate a keyframe - if generated by translation only a minimum number of frames in the buffer is required - or a new tracking context
    if (_degrees_rotated_window   > _minimum_degrees_rotated_for_keyframe                                                                                 ||
        (_distance_traveled_window > _minimum_distance_traveled_for_keyframe && _frame_queue_for_keyframe.size() > _minimum_number_of_frames_for_keyframe)||
        (_frame_queue_for_keyframe.size() > _minimum_number_of_frames_for_keyframe && _keyframes.size() < 5)                                              ) {

      //ds create the new keyframe and add it to the keyframe database
      _current_keyframe = new KeyFrame(_current_frame, _frame_queue_for_keyframe);
      _keyframes.push_back(_current_keyframe);
      _generated_keyframe = true;

      //ds reset generation properties
      resetWindow();

      //ds current frame is now a keyframe - update structures
      _current_frame = _current_keyframe;
      _frames.replace(_current_frame);

//      std::cerr << "TrackingContext::createNewKeyframe|created keyframe: " << _current_frame->index() << " in context: " << index() << std::endl;
    }
  }
  
  Landmark* TrackingContext::createNewLandmark(const PointCoordinates& coordinates_in_world_){
    Landmark* landmark = new Landmark(coordinates_in_world_);
    landmark->createNewItem(landmark->coordinates());
    _landmarks.put(landmark);
    return landmark;
  }

  void TrackingContext::closeKeyframes(KeyFrame* query_,
                                       const KeyFrame* reference_,
                                       const TransformMatrix3D& transform_query_to_reference_) {
    query_->add(reference_, transform_query_to_reference_);
    _closed_keyframe = true;
  }

  void TrackingContext::resetWindow() {
    _distance_traveled_window = 0.0;
    _degrees_rotated_window   = 0.0;
  }

  void TrackingContext::absorb(TrackingContext* context_query_, const TransformMatrix3D& transform_query_world_to_reference_world_) {

    //ds iterate over all landmarks (order does not matter)
    for(LandmarkPtrMapElement landmark_with_index: context_query_->landmarks()) {

      //ds merge landmark properties
      Landmark* landmark = landmark_with_index.second;
      const PointCoordinates& coordinates_in_reference = transform_query_world_to_reference_world_*landmark->coordinates();
      landmark->setCoordinates(coordinates_in_reference);
      landmark->resetCoordinates();

      //ds add to control structure
      _landmarks.put(landmark);
    }

    //ds iterate over all frames (order does matter)
    Frame* frame = context_query_->rootFrame();
    while (frame) {

      //ds merge frame properties
      frame->setTrackingContext(this);
      const TransformMatrix3D& frame_to_world_in_reference = transform_query_world_to_reference_world_*frame->robotToWorld();
      frame->setRobotToWorld(frame_to_world_in_reference);

      //ds add to control structure
      _previous_frame = _current_frame;
      _current_frame  = frame;
      _current_frame->setPrevious(_previous_frame);
      _previous_frame->setNext(_current_frame);
      _frames.put(_current_frame);

      //ds check if the frame is a keyframe
      if (_current_frame->isKeyFrame()) {
        KeyFrame* keyframe_in_reference = static_cast<KeyFrame*>(_current_frame);
        keyframe_in_reference->updateSubContext();
        _current_keyframe = keyframe_in_reference;
        _keyframes.push_back(keyframe_in_reference);
      }

      //ds move on
      frame = _current_frame->next();
    }

    //ds update last position
    setRobotToWorldPrevious(_current_frame->robotToWorld());

    //ds purge ties to all objects in the absorbed context
    context_query_->clear();
    delete context_query_;
  }

  void TrackingContext::purifyLandmarks() {

    //ds deactivate all landmarks which are not optimized
    for (const LandmarkPtrMapElement landmark_element: _landmarks) {
      if (!landmark_element.second->isOptimized()) {
        landmark_element.second->setIsContained(false);
      }
    }
  }
}

